<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gapi - Google Places Search</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif; background: #0f0f23; min-height: 100vh; color: #fff; }
    
    .header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 30px 40px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .header h1 { font-size: 2em; margin-bottom: 8px; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .header p { color: rgba(255,255,255,0.6); font-size: 0.95em; }
    
    .search-section { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 30px 40px; display: flex; gap: 20px; align-items: flex-end; flex-wrap: wrap; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .input-group { flex: 1; min-width: 250px; max-width: 400px; }
    .input-group label { display: block; margin-bottom: 8px; color: rgba(255,255,255,0.7); font-size: 13px; text-transform: uppercase; letter-spacing: 1px; }
    .input-wrapper { position: relative; }
    .location-input { width: 100%; padding: 16px 50px 16px 20px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; color: #fff; font-size: 16px; transition: all 0.3s; }
    .location-input:focus { outline: none; border-color: #667eea; background: rgba(102, 126, 234, 0.1); }
    .location-input::placeholder { color: rgba(255,255,255,0.3); }
    .geo-btn { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 20px; padding: 8px; border-radius: 8px; transition: all 0.3s; }
    .geo-btn:hover { background: rgba(102, 126, 234, 0.2); }
    .geo-btn.loading { animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* Place Type Select Styling */
    #typeInput {
      width: 100%;
      padding: 16px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 18px;
      padding-right: 40px;
    }
    #typeInput:focus {
      outline: none;
      border-color: #667eea;
      background-color: rgba(102, 126, 234, 0.1);
    }
    #typeInput:hover {
      border-color: rgba(255,255,255,0.2);
      background-color: rgba(255,255,255,0.08);
    }
    #typeInput option {
      background: #1a1a2e;
      color: #fff;
      padding: 12px;
      font-size: 16px;
    }
    
    .btn-search { padding: 16px 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 12px; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.3s; }
    .btn-search:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4); }
    .btn-search:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    
    .stats-bar { display: flex; gap: 40px; padding: 25px 40px; background: rgba(255,255,255,0.02); border-bottom: 1px solid rgba(255,255,255,0.05); flex-wrap: wrap; }
    .stat { display: flex; align-items: center; gap: 15px; }
    .stat-icon { width: 50px; height: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 22px; }
    .stat-info .label { color: rgba(255,255,255,0.5); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
    .stat-info .value { color: #fff; font-size: 1.4em; font-weight: 700; }
    
    .results-section { padding: 40px; }
    .section-title { font-size: 1.5em; margin-bottom: 25px; color: rgba(255,255,255,0.9); }
    
    .cards-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 25px; }
    
    .place-card { background: linear-gradient(145deg, #1e1e3f 0%, #16162a 100%); border-radius: 20px; overflow: hidden; border: 1px solid rgba(255,255,255,0.05); transition: all 0.3s; opacity: 0; transform: translateY(20px); animation: fadeInUp 0.5s ease forwards; }
    .place-card:hover { transform: translateY(-5px); border-color: rgba(102, 126, 234, 0.3); box-shadow: 0 20px 40px rgba(0,0,0,0.3); }
    @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }
    
    .card-image { width: 100%; height: 180px; object-fit: cover; background: rgba(255,255,255,0.05); }
    .card-image-placeholder { width: 100%; height: 180px; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%); font-size: 48px; }
    
    .card-header { padding: 25px; position: relative; }
    .card-header::after { content: ''; position: absolute; bottom: 0; left: 25px; right: 25px; height: 1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); }
    .card-header h3 { font-size: 1.3em; margin-bottom: 12px; color: #fff; }
    .card-types { display: flex; flex-wrap: wrap; gap: 8px; }
    .card-type { display: inline-block; padding: 5px 12px; background: rgba(102, 126, 234, 0.2); color: #667eea; border-radius: 20px; font-size: 12px; text-transform: capitalize; }
    
    .card-body { padding: 25px; }
    .info-row { display: flex; align-items: flex-start; gap: 15px; margin-bottom: 18px; }
    .info-icon { width: 24px; height: 24px; background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
    .info-content { flex: 1; }
    .info-label { font-size: 11px; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
    .info-value { color: rgba(255,255,255,0.9); font-size: 14px; line-height: 1.4; }
    
    .rating-row { display: flex; align-items: center; gap: 12px; margin-bottom: 18px; }
    .rating-badge { display: flex; align-items: center; gap: 6px; background: rgba(244, 180, 0, 0.15); padding: 8px 14px; border-radius: 10px; }
    .rating-badge .star { color: #f4b400; font-size: 18px; }
    .rating-badge .score { font-weight: 700; font-size: 16px; }
    .review-count { color: rgba(255,255,255,0.5); font-size: 13px; }
    
    .status-row { display: flex; gap: 15px; flex-wrap: wrap; }
    .status-badge { display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 10px; font-size: 13px; font-weight: 600; }
    .status-badge.open { background: rgba(19, 115, 51, 0.2); color: #4caf50; }
    .status-badge.closed { background: rgba(197, 34, 31, 0.2); color: #f44336; }
    .price-badge { background: rgba(15, 157, 88, 0.2); color: #0f9d58; }
    
    .card-footer { padding: 20px 25px; background: rgba(0,0,0,0.2); border-top: 1px solid rgba(255,255,255,0.05); }
    .place-id { font-size: 11px; color: rgba(255,255,255,0.3); font-family: monospace; word-break: break-all; }
    .coordinates { font-size: 11px; color: rgba(255,255,255,0.3); margin-top: 5px; }
    
    .loading { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 80px 20px; color: rgba(255,255,255,0.6); }
    .spinner { width: 60px; height: 60px; border: 4px solid rgba(255,255,255,0.1); border-top-color: #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    .infinite-loader { grid-column: 1 / -1; display: flex; justify-content: center; padding: 40px; }
    .infinite-loader .spinner { width: 50px; height: 50px; margin-bottom: 0; }
    
    .no-results { text-align: center; padding: 80px 20px; color: rgba(255,255,255,0.5); grid-column: 1 / -1; }
    .no-results .icon { font-size: 64px; margin-bottom: 20px; opacity: 0.5; }
    .no-results h3 { font-size: 1.5em; margin-bottom: 10px; color: rgba(255,255,255,0.7); }
    
    .error { background: rgba(197, 34, 31, 0.1); border: 1px solid rgba(197, 34, 31, 0.3); color: #f44336; padding: 20px; border-radius: 12px; text-align: center; margin: 20px 40px; }
    
    .sentinel { grid-column: 1 / -1; height: 20px; }
    
    @media (max-width: 1400px) { .cards-container { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 1100px) { .cards-container { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 768px) { .cards-container { grid-template-columns: 1fr; } .search-section, .stats-bar, .results-section { padding: 20px; } .header h1 { font-size: 1.5em; } }
  </style>
</head>
<body>
  <div class="header">
    <h1>üîç Gapi - Places Search</h1>
    <p>Discover the best places around the world</p>
  </div>
  
  <div class="search-section">
    <div class="input-group">
      <label>üìç Location</label>
      <div class="input-wrapper">
        <input type="text" id="locationInput" class="location-input" placeholder="Enter city or address" value="">
        <button class="geo-btn" id="geoBtn" onclick="getCurrentLocation()" title="Use my current location">
          üìç
        </button>
      </div>
      <datalist id="locations">
        <option value="Delhi">
        <option value="Mumbai">
        <option value="Bangalore">
        <option value="Chennai">
        <option value="Kolkata">
        <option value="Hyderabad">
        <option value="Pune">
        <option value="New York">
        <option value="Los Angeles">
        <option value="San Francisco">
        <option value="London">
        <option value="Paris">
        <option value="Tokyo">
        <option value="Dubai">
        <option value="Singapore">
        <option value="Sydney">
        <option value="Toronto">
        <option value="Melbourne">
        <option value="Berlin">
        <option value="Amsterdam">
      </datalist>
    </div>
    
    <div class="input-group">
      <label>üè∑Ô∏è Place Type</label>
      <select id="typeInput">
        <option value="all">All Places</option>
        <option value="restaurants">Restaurants</option>
        <option value="cafes">Cafes</option>
        <option value="hotels">Hotels</option>
        <option value="hospitals">Hospitals</option>
        <option value="banks">Banks</option>
        <option value="gas stations">Gas Stations</option>
        <option value="shopping malls">Shopping Malls</option>
        <option value="parks">Parks</option>
        <option value="gyms">Gyms</option>
        <option value="schools">Schools</option>
        <option value="pharmacies">Pharmacies</option>
        <option value="bars">Bars & Pubs</option>
        <option value="beaches">Beaches</option>
        <option value="museums">Museums</option>
        <option value="airports">Airports</option>
      </select>
    </div>
    
    <button class="btn-search" onclick="searchPlaces()" id="searchBtn">Search</button>
  </div>
  
  <div class="stats-bar" id="stats" style="display: none;">
    <div class="stat">
      <div class="stat-icon">üìä</div>
      <div class="stat-info">
        <div class="label">Results</div>
        <div class="value" id="resultCount">0</div>
      </div>
    </div>
    <div class="stat">
      <div class="stat-icon">üèôÔ∏è</div>
      <div class="stat-info">
        <div class="label">City</div>
        <div class="value" id="cityDisplay">Detecting...</div>
      </div>
    </div>
    <div class="stat">
      <div class="stat-icon">üìç</div>
      <div class="stat-info">
        <div class="label">Location</div>
        <div class="value" id="locationDisplay">-</div>
      </div>
    </div>
    <div class="stat">
      <div class="stat-icon">üè∑Ô∏è</div>
      <div class="stat-info">
        <div class="label">Category</div>
        <div class="value" id="typeDisplay">-</div>
      </div>
    </div>
  </div>
  
  <div class="results-section">
    <h2 class="section-title" id="sectionTitle">Search Results</h2>
    <div id="results" class="cards-container"></div>
    <div id="infiniteLoader" class="infinite-loader" style="display: none;">
      <div class="spinner"></div>
      <p style="margin-top: 10px; color: rgba(255,255,255,0.6);">Loading more results...</p>
    </div>
    <div id="sentinel" class="sentinel"></div>
  </div>

  <script>
    const API_URL = 'http://localhost:5000/api/places';
    
    // State management
    let allResults = [];
    let nextPageToken = null;
    let currentLocation = '';
    let currentType = '';
    let isLoading = false;
    let observer = null;
    
    // Get current location on page load
    window.addEventListener('DOMContentLoaded', () => {
      getCurrentLocation();
    });
    
    // Get user's current location with full address
    async function getCurrentLocation() {
      const locationInput = document.getElementById('locationInput');
      const geoBtn = document.getElementById('geoBtn');
      const cityDisplay = document.getElementById('cityDisplay');
      
      if (!navigator.geolocation) {
        locationInput.placeholder = 'Geolocation not supported';
        cityDisplay.textContent = 'Not supported';
        return;
      }
      
      geoBtn.classList.add('loading');
      geoBtn.innerHTML = '‚è≥';
      
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const { latitude, longitude } = position.coords;
          
          // Try to get full address from coordinates
          try {
            const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=AIzaSyDq3eLU5UMm5kKZNvwyofR0bC3rMToQ-hw`);
            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
              const result = data.results[0];
              const fullAddress = result.formatted_address;
              
              // Extract city name from address components
              const addressComponents = result.address_components || [];
              let cityName = '';
              
              for (const component of addressComponents) {
                if (component.types.includes('locality')) {
                  cityName = component.long_name;
                  break;
                } else if (component.types.includes('sublocality') && !cityName) {
                  cityName = component.long_name;
                }
              }
              
              // Update city display
              if (cityName) {
                cityDisplay.textContent = cityName;
                locationInput.value = cityName;
                currentLocation = cityName;
              } else if (fullAddress) {
                // Fallback: use first part of address
                const addressParts = fullAddress.split(', ');
                cityDisplay.textContent = addressParts[0] || fullAddress;
                locationInput.value = fullAddress;
                currentLocation = fullAddress;
              } else {
                cityDisplay.textContent = `${latitude.toFixed(2)}, ${longitude.toFixed(2)}`;
                locationInput.value = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                currentLocation = locationInput.value;
              }
              
              // Auto-search with current location
              searchPlaces();
            } else {
              cityDisplay.textContent = `${latitude.toFixed(2)}, ${longitude.toFixed(2)}`;
              locationInput.value = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
              currentLocation = locationInput.value;
            }
          } catch (error) {
            cityDisplay.textContent = 'Unknown';
            locationInput.value = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
            currentLocation = locationInput.value;
          }
          
          geoBtn.classList.remove('loading');
          geoBtn.innerHTML = 'üìç';
        },
        (error) => {
          console.error('Geolocation error:', error);
          geoBtn.classList.remove('loading');
          geoBtn.innerHTML = 'üìç';
          cityDisplay.textContent = 'Permission denied';
          locationInput.placeholder = 'Enter city or address';
          locationInput.focus();
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }
    
    function createCardHTML(place, index) {
      const photoUrl = place.photos && place.photos[0] 
        ? `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photo_reference=${place.photos[0].photo_reference}&key=AIzaSyDq3eLU5UMm5kKZNvwyofR0bC3rMToQ-hw`
        : null;
      const typeEmoji = getTypeEmoji(place.types?.[0] || '');
      
      return `
        <div class="place-card" style="animation-delay: ${index * 0.1}s">
          ${photoUrl ? 
            `<img class="card-image" src="${photoUrl}" alt="${place.name}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">` +
            `<div class="card-image-placeholder" style="display:none;">${typeEmoji}</div>`
            : 
            `<div class="card-image-placeholder">${typeEmoji}</div>`
          }
          <div class="card-header">
            <h3>${place.name}</h3>
            <div class="card-types">
              ${place.types ? place.types.map(t => `<span class="card-type">${t.replace(/_/g, ' ')}</span>`).join('') : '<span class="card-type">Place</span>'}
            </div>
          </div>
          <div class="card-body">
            <div class="info-row">
              <div class="info-icon">üìç</div>
              <div class="info-content">
                <div class="info-label">Address</div>
                <div class="info-value">${place.formatted_address || place.vicinity || 'N/A'}</div>
              </div>
            </div>
            <div class="rating-row">
              ${place.rating ? `
                <div class="rating-badge">
                  <span class="star">‚òÖ</span>
                  <span class="score">${place.rating}</span>
                </div>
                <span class="review-count">${place.user_ratings_total} reviews</span>
              ` : '<span class="review-count">No ratings yet</span>'}
            </div>
            <div class="status-row">
              <div class="status-badge ${place.opening_hours?.open_now ? 'open' : 'closed'}">
                ${place.opening_hours?.open_now ? '‚úì Open' : '‚úó Closed'}
              </div>
              ${place.price_level ? `
                <div class="status-badge price-badge">
                  üí∞ ${'$'.repeat(place.price_level)}
                </div>
              ` : ''}
              ${place.business_status ? `
                <div class="status-badge" style="background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.7);">
                  üìã ${place.business_status}
                </div>
              ` : ''}
            </div>
          </div>
          <div class="card-footer">
            <div class="place-id">${place.place_id}</div>
            <div class="coordinates">Lat: ${place.geometry?.location?.lat?.toFixed(4) || 'N/A'}, Lng: ${place.geometry?.location?.lng?.toFixed(4) || 'N/A'}</div>
          </div>
        </div>
      `;
    }
    
    // Helper function to get emoji based on place type
    function getTypeEmoji(type) {
      const emojis = {
        'restaurant': 'üçΩÔ∏è',
        'cafe': '‚òï',
        'bar': 'üç∏',
        'hotel': 'üè®',
        'hospital': 'üè•',
        'bank': 'üè¶',
        'gas_station': '‚õΩ',
        'shopping_mall': 'üõçÔ∏è',
        'park': 'üå≥',
        'gym': 'üí™',
        'school': 'üè´',
        'pharmacy': 'üíä',
        'beach': 'üèñÔ∏è',
        'museum': 'üèõÔ∏è',
        'airport': '‚úàÔ∏è',
        'default': 'üìç'
      };
      return emojis[type] || emojis[type.replace(/\s+/g, '_')] || emojis.default;
    }
    
    // Setup Intersection Observer for infinite scroll - triggers on little scroll
    function setupObserver() {
      if (observer) {
        observer.disconnect();
      }
      
      const sentinel = document.getElementById('sentinel');
      
      observer = new IntersectionObserver((entries) => {
        const entry = entries[0];
        if (entry.isIntersecting && nextPageToken && !isLoading) {
          loadMore();
        }
      }, {
        rootMargin: '50px', // Reduced from 200px - triggers with little scroll
        threshold: 0
      });
      
      observer.observe(sentinel);
      
      // Also add scroll listener for immediate response on little scroll
      window.addEventListener('scroll', handleScroll);
    }
    
    // Scroll handler for auto-loading on little scroll
    let scrollTimeout;
    function handleScroll() {
      if (scrollTimeout) return;
      
      scrollTimeout = requestAnimationFrame(() => {
        if (nextPageToken && !isLoading) {
          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = document.documentElement.clientHeight;
          const scrollTop = window.scrollY || document.documentElement.scrollTop;
          const scrollBottom = scrollHeight - scrollTop - clientHeight;
          
          // Trigger when within 100px of bottom
          if (scrollBottom < 100) {
            loadMore();
          }
        }
        scrollTimeout = null;
      });
    }
    
    async function searchPlaces() {
      const location = document.getElementById('locationInput').value.trim();
      const type = document.getElementById('typeInput').value;
      // For "all" type, search without specific place type
      const query = type === 'all' ? location : `${type} in ${location}`;
      const resultsDiv = document.getElementById('results');
      const searchBtn = document.getElementById('searchBtn');
      const statsDiv = document.getElementById('stats');
      const sectionTitle = document.getElementById('sectionTitle');
      const infiniteLoader = document.getElementById('infiniteLoader');

      if (!location) {
        resultsDiv.innerHTML = '<div class="error">Please enter a location</div>';
        return;
      }

      // Reset state
      allResults = [];
      nextPageToken = null;
      currentLocation = location;
      currentType = type;
      isLoading = true;

      resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div><p>Searching for places...</p></div>';
      searchBtn.disabled = true;
      statsDiv.style.display = 'none';
      infiniteLoader.style.display = 'none';
      sectionTitle.textContent = `Searching in ${location}...`;

      try {
        const response = await fetch(`${API_URL}?query=${encodeURIComponent(query)}&type=${encodeURIComponent(type)}`);
        const data = await response.json();

        if (data.error) {
          resultsDiv.innerHTML = `<div class="error">${data.error}</div>`;
          isLoading = false;
          return;
        }

        if (!data.results || data.results.length === 0) {
          resultsDiv.innerHTML = `
            <div class="no-results">
              <div class="icon">üîç</div>
              <h3>No places found</h3>
              <p>Try a different location or category</p>
            </div>`;
          sectionTitle.textContent = 'No Results';
          isLoading = false;
          return;
        }

        // Store results and pagination token
        allResults = data.results;
        nextPageToken = data.next_page_token || null;

        // Update stats and title
        document.getElementById('resultCount').textContent = allResults.length;
        document.getElementById('cityDisplay').textContent = location;
        document.getElementById('locationDisplay').textContent = location;
        document.getElementById('typeDisplay').textContent = type.charAt(0).toUpperCase() + type.slice(1);
        statsDiv.style.display = 'flex';
        sectionTitle.textContent = `Top ${allResults.length} ${type.charAt(0).toUpperCase() + type.slice(1)} in ${location}`;

        // Render cards
        resultsDiv.innerHTML = allResults.map((place, index) => createCardHTML(place, index)).join('');

        // Setup infinite scroll observer
        setupObserver();

        // Show loader if more results available
        if (nextPageToken) {
          infiniteLoader.style.display = 'flex';
        }

        isLoading = false;
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error">Failed to connect to API: ${error.message}</div>`;
        isLoading = false;
      } finally {
        searchBtn.disabled = false;
      }
    }
    
    async function loadMore() {
      if (isLoading || !nextPageToken) return;
      
      const infiniteLoader = document.getElementById('infiniteLoader');
      const resultsDiv = document.getElementById('results');
      const searchBtn = document.getElementById('searchBtn');
      
      isLoading = true;
      infiniteLoader.style.display = 'flex';
      searchBtn.disabled = true;

      try {
        const location = currentLocation;
        const type = currentType;
        // For "all" type, search without specific place type
        const query = type === 'all' ? location : `${type} in ${location}`;
        
        const response = await fetch(`${API_URL}?query=${encodeURIComponent(query)}&type=${encodeURIComponent(type)}&pagetoken=${encodeURIComponent(nextPageToken)}`);
        const data = await response.json();

        if (data.results && data.results.length > 0) {
          allResults = [...allResults, ...data.results];
          nextPageToken = data.next_page_token || null;

          const newCardsHTML = data.results.map((place, index) => createCardHTML(place, allResults.length - data.results.length + index)).join('');
          resultsDiv.insertAdjacentHTML('beforeend', newCardsHTML);

          document.getElementById('resultCount').textContent = allResults.length;
          sectionTitle.textContent = `Top ${allResults.length} ${type.charAt(0).toUpperCase() + type.slice(1)} in ${location}`;
        }

        if (nextPageToken) {
          infiniteLoader.style.display = 'flex';
        } else {
          infiniteLoader.style.display = 'none';
        }
      } catch (error) {
        console.error('Error loading more results:', error);
        infiniteLoader.style.display = 'flex';
      } finally {
        isLoading = false;
        searchBtn.disabled = false;
      }
    }

    // Allow Enter key to search
    document.getElementById('locationInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchPlaces();
    });

    // Auto-search on type change
    document.getElementById('typeInput').addEventListener('change', () => {
      if (document.getElementById('locationInput').value.trim()) {
        searchPlaces();
      }
    });
  </script>
</body>
</html>
